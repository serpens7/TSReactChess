{"ast":null,"code":"import { Cell } from \"./Cell\";\nimport { Colors } from \"./Colors\";\nimport { Bishop } from \"./figures/Bishop\";\nimport { King } from \"./figures/King\";\nimport { Knight } from \"./figures/Knight\";\nimport { Pawn } from \"./figures/Pawn\";\nimport { Queen } from \"./figures/Queen\";\nimport { Rook } from \"./figures/Rook\";\nexport class Board {\n  constructor() {\n    this.cells = [];\n    this.lostBlackFigures = [];\n    this.lostWhiteFigures = [];\n    this.checkMate = false;\n    this.isPawnWentTwoCellLastTurn = false;\n    this.currentEnPassantFigure = null;\n    this.whiteKing = void 0;\n    this.blackKing = void 0;\n  }\n  isRoqueAvailable(king, targetCell) {\n    //if (this.isCellUnderAttack(board.getCell(kingCell.x, kingCell.y), kingCell?.figure.color))\n    const direction = king.cell.x - targetCell.x > 0 ? -1 : 1;\n    const rookX = direction > 0 ? 7 : 0;\n    const rook = this.getCell(rookX, king.cell.y).figure;\n    if (!king || !rook || king.madeAMove || rook.madeAMove) return false;\n    if (this.isCellUnderAttack(king.cell, this.getOppositeColor(king.color))) return false;\n    let cellX = king.cell.x + direction;\n    while (cellX !== rookX) {\n      const cell = this.getCell(cellX, king.cell.y);\n      if (cell.figure) return false;\n      if (this.isCellUnderAttack(cell, this.getOppositeColor(king.color))) return false;\n      cellX += direction;\n    }\n    return true;\n\n    /*     king.color === (king.cell.x).color &&\n      king.madeAMove === false &&\n      rook.madeAMove === false &&\n      this.isCellUnderAttack(king.cell, this.getOppositeColor(king.color)) &&\n      !this.isCellUnderAttack(\n        this.getCell(king.cell.x + direction, king.cell.y),\n        this.getOppositeColor(king.color)\n      ) &&\n      !this.isCellUnderAttack(\n        this.getCell(king.cell.x + 2 * direction, king.cell.y),\n        this.getOppositeColor(king.color)\n      )\n    )\n      return true;\n    return false; */\n  }\n\n  // 1. Взять цвет текущего игрока\n  // 2. Пройтись по всем фигурам этого цвета\n  // 3. Проверить может ли эта фигура хоть куда-то сходить\n  // 4. Если хоть одна может - не checkMate\n\n  isFigureHasAnyMove(figure) {\n    for (let j = 0; j < this.cells.length; j++) {\n      for (let i = 0; i < this.cells.length; i++) {\n        const targetCell = this.getCell(j, i);\n        if (figure !== null && figure !== void 0 && figure.canMove(targetCell) && this.isAvailableMove(figure, figure.cell, targetCell)) return true;\n      }\n    }\n    return false;\n  }\n  checkCheckMate(playerColor) {\n    for (let k = 0; k < this.cells.length; k++) {\n      for (let i = 0; i < this.cells.length; i++) {\n        const cell = this.getCell(k, i);\n        if (cell.figure && cell.figure.color === playerColor && this.isFigureHasAnyMove(cell.figure)) return false;\n      }\n    }\n    console.log(\"bt\");\n    return true;\n  }\n  initCells() {\n    for (let i = 0; i < 8; i++) {\n      const row = [];\n      for (let j = 0; j < 8; j++) {\n        if ((i + j) % 2 !== 0) {\n          row.push(new Cell(this, j, i, Colors.BLACK, null));\n        } else {\n          row.push(new Cell(this, j, i, Colors.WHITE, null));\n        }\n      }\n      this.cells.push(row);\n    }\n  }\n  isAvailableMove(figure, startCell, targetCell) {\n    let targetFigure = targetCell.figure;\n    targetCell.figure = figure;\n    figure.cell = targetCell;\n    startCell.figure = null;\n    let king;\n    if (figure.color === Colors.WHITE) {\n      king = this.whiteKing;\n    } else {\n      king = this.blackKing;\n    }\n    var isKingUnderAttack = this.isCellUnderAttack(king.cell, this.getOppositeColor(king.color));\n    figure.cell = startCell;\n    startCell.figure = figure;\n    targetCell.figure = targetFigure;\n    return !isKingUnderAttack;\n  }\n  getOppositeColor(color) {\n    if (color === Colors.WHITE) return Colors.BLACK;\n    if (color === Colors.BLACK) return Colors.WHITE;\n    return Colors.WHITE; //заглушка\n  }\n\n  isCellUnderAttack(targetCell, enemyColor) {\n    for (let i = 0; i < this.cells.length; i++) {\n      let row = this.cells[i];\n      let cellWithCheckFigure = row.find(cell => cell.figure && cell.figure.color === enemyColor && cell.figure.canMove(targetCell));\n      if (cellWithCheckFigure) return true;\n    }\n    return false;\n  }\n  getCell(x, y) {\n    return this.cells[y][x];\n  }\n  getCopyBoard() {\n    const newBoard = new Board();\n    newBoard.checkMate = this.checkMate;\n    newBoard.cells = this.cells;\n    newBoard.lostWhiteFigures = this.lostWhiteFigures;\n    newBoard.lostBlackFigures = this.lostBlackFigures;\n    newBoard.whiteKing = this.whiteKing;\n    newBoard.blackKing = this.blackKing;\n    return newBoard;\n  }\n  highLightCells(selectedCell) {\n    for (let i = 0; i < this.cells.length; i++) {\n      const row = this.cells[i];\n      for (let j = 0; j < this.cells.length; j++) {\n        var _selectedCell$figure;\n        const target = row[j];\n        target.available = !!(selectedCell !== null && selectedCell !== void 0 && (_selectedCell$figure = selectedCell.figure) !== null && _selectedCell$figure !== void 0 && _selectedCell$figure.canMove(target) && this.isAvailableMove(selectedCell.figure, selectedCell, target));\n      }\n    }\n  }\n  addLostFigure(figure) {\n    figure.color === Colors.BLACK ? this.lostBlackFigures.push(figure) : this.lostWhiteFigures.push(figure);\n  }\n  addFigures() {\n    this.addQueen();\n    this.addKing();\n    this.addKnight();\n    this.addRook();\n    this.addBishop();\n    this.addPawn();\n  }\n  addBishop() {\n    new Bishop(Colors.WHITE, this.getCell(2, 7), this);\n    new Bishop(Colors.WHITE, this.getCell(5, 7), this);\n    new Bishop(Colors.BLACK, this.getCell(2, 0), this);\n    new Bishop(Colors.BLACK, this.getCell(5, 0), this);\n  }\n  addKing() {\n    this.whiteKing = new King(Colors.WHITE, this.getCell(4, 7), this);\n    this.blackKing = new King(Colors.BLACK, this.getCell(4, 0), this);\n  }\n  addPawn() {\n    for (let i = 0; i < 8; i++) {\n      new Pawn(Colors.WHITE, this.getCell(i, 6), this);\n      new Pawn(Colors.BLACK, this.getCell(i, 1), this);\n    }\n  }\n  addQueen() {\n    new Queen(Colors.WHITE, this.getCell(3, 7), this);\n    new Queen(Colors.BLACK, this.getCell(3, 0), this);\n  }\n  addKnight() {\n    new Knight(Colors.WHITE, this.getCell(1, 7), this);\n    new Knight(Colors.WHITE, this.getCell(6, 7), this);\n    new Knight(Colors.BLACK, this.getCell(1, 0), this);\n    new Knight(Colors.BLACK, this.getCell(6, 0), this);\n  }\n  addRook() {\n    new Rook(Colors.WHITE, this.getCell(0, 7), this);\n    new Rook(Colors.WHITE, this.getCell(7, 7), this);\n    new Rook(Colors.BLACK, this.getCell(0, 0), this);\n    new Rook(Colors.BLACK, this.getCell(7, 0), this);\n  }\n}","map":{"version":3,"names":["Cell","Colors","Bishop","King","Knight","Pawn","Queen","Rook","Board","constructor","cells","lostBlackFigures","lostWhiteFigures","checkMate","isPawnWentTwoCellLastTurn","currentEnPassantFigure","whiteKing","blackKing","isRoqueAvailable","king","targetCell","direction","cell","x","rookX","rook","getCell","y","figure","madeAMove","isCellUnderAttack","getOppositeColor","color","cellX","isFigureHasAnyMove","j","length","i","canMove","isAvailableMove","checkCheckMate","playerColor","k","console","log","initCells","row","push","BLACK","WHITE","startCell","targetFigure","isKingUnderAttack","enemyColor","cellWithCheckFigure","find","getCopyBoard","newBoard","highLightCells","selectedCell","_selectedCell$figure","target","available","addLostFigure","addFigures","addQueen","addKing","addKnight","addRook","addBishop","addPawn"],"sources":["C:/Users/jar50/Desktop/chessWithCheck/src/models/Board.ts"],"sourcesContent":["import { Cell } from \"./Cell\";\nimport { Colors } from \"./Colors\";\nimport { Bishop } from \"./figures/Bishop\";\nimport { King } from \"./figures/King\";\nimport { Knight } from \"./figures/Knight\";\nimport { Pawn } from \"./figures/Pawn\";\nimport { Queen } from \"./figures/Queen\";\nimport { Rook } from \"./figures/Rook\";\nimport { Figure } from \"./figures/Figure\";\n\nexport class Board {\n  cells: Cell[][] = [];\n  lostBlackFigures: Figure[] = [];\n  lostWhiteFigures: Figure[] = [];\n  checkMate: boolean = false;\n  isPawnWentTwoCellLastTurn: boolean = false;\n  currentEnPassantFigure = null;\n\n  whiteKing?: King;\n  blackKing?: King;\n\n  isRoqueAvailable(king: any, targetCell: any): boolean {\n    //if (this.isCellUnderAttack(board.getCell(kingCell.x, kingCell.y), kingCell?.figure.color))\n    const direction = king.cell.x - targetCell.x > 0 ? -1 : 1;\n    const rookX = direction > 0 ? 7 : 0;\n    const rook = this.getCell(rookX, king.cell.y).figure;\n    if (!king || !rook || king.madeAMove || rook.madeAMove) return false;\n\n    if (this.isCellUnderAttack(king.cell, this.getOppositeColor(king.color)))\n      return false;\n\n    let cellX = king.cell.x + direction;\n    while (cellX !== rookX) {\n      const cell = this.getCell(cellX, king.cell.y);\n      if (cell.figure) return false;\n      if (this.isCellUnderAttack(cell, this.getOppositeColor(king.color)))\n        return false;\n      cellX += direction;\n    }\n    return true;\n\n    /*     king.color === (king.cell.x).color &&\n      king.madeAMove === false &&\n      rook.madeAMove === false &&\n      this.isCellUnderAttack(king.cell, this.getOppositeColor(king.color)) &&\n      !this.isCellUnderAttack(\n        this.getCell(king.cell.x + direction, king.cell.y),\n        this.getOppositeColor(king.color)\n      ) &&\n      !this.isCellUnderAttack(\n        this.getCell(king.cell.x + 2 * direction, king.cell.y),\n        this.getOppositeColor(king.color)\n      )\n    )\n      return true;\n    return false; */\n  }\n\n  // 1. Взять цвет текущего игрока\n  // 2. Пройтись по всем фигурам этого цвета\n  // 3. Проверить может ли эта фигура хоть куда-то сходить\n  // 4. Если хоть одна может - не checkMate\n\n  isFigureHasAnyMove(figure: Figure): boolean {\n    for (let j = 0; j < this.cells.length; j++) {\n      for (let i = 0; i < this.cells.length; i++) {\n        const targetCell = this.getCell(j, i);\n        if (\n          figure?.canMove(targetCell) &&\n          this.isAvailableMove(figure, figure.cell, targetCell)\n        )\n          return true;\n      }\n    }\n    return false;\n  }\n\n  checkCheckMate(playerColor: Colors): boolean {\n    for (let k = 0; k < this.cells.length; k++) {\n      for (let i = 0; i < this.cells.length; i++) {\n        const cell = this.getCell(k, i);\n        if (\n          cell.figure &&\n          cell.figure.color === playerColor &&\n          this.isFigureHasAnyMove(cell.figure)\n        )\n          return false;\n      }\n    }\n    console.log(\"bt\");\n    return true;\n  }\n\n  public initCells() {\n    for (let i = 0; i < 8; i++) {\n      const row: Cell[] = [];\n      for (let j = 0; j < 8; j++) {\n        if ((i + j) % 2 !== 0) {\n          row.push(new Cell(this, j, i, Colors.BLACK, null));\n        } else {\n          row.push(new Cell(this, j, i, Colors.WHITE, null));\n        }\n      }\n      this.cells.push(row);\n    }\n  }\n\n  public isAvailableMove(\n    figure: Figure,\n    startCell: Cell,\n    targetCell: Cell\n  ): boolean {\n    let targetFigure = targetCell.figure;\n    targetCell.figure = figure;\n    figure.cell = targetCell;\n    startCell.figure = null;\n    let king: any;\n    if (figure.color === Colors.WHITE) {\n      king = this.whiteKing;\n    } else {\n      king = this.blackKing;\n    }\n    var isKingUnderAttack: boolean = this.isCellUnderAttack(\n      king.cell,\n      this.getOppositeColor(king.color)\n    );\n    figure.cell = startCell;\n    startCell.figure = figure;\n    targetCell.figure = targetFigure;\n\n    return !isKingUnderAttack;\n  }\n\n  getOppositeColor(color: Colors) {\n    if (color === Colors.WHITE) return Colors.BLACK;\n    if (color === Colors.BLACK) return Colors.WHITE;\n    return Colors.WHITE; //заглушка\n  }\n\n  public isCellUnderAttack(targetCell: Cell, enemyColor: Colors): boolean {\n    for (let i = 0; i < this.cells.length; i++) {\n      let row = this.cells[i];\n      let cellWithCheckFigure = row.find(\n        (cell) =>\n          cell.figure &&\n          cell.figure.color === enemyColor &&\n          cell.figure.canMove(targetCell)\n      );\n      if (cellWithCheckFigure) return true;\n    }\n    return false;\n  }\n\n  public getCell(x: number, y: number) {\n    return this.cells[y][x];\n  }\n\n  public getCopyBoard(): Board {\n    const newBoard = new Board();\n    newBoard.checkMate = this.checkMate;\n    newBoard.cells = this.cells;\n    newBoard.lostWhiteFigures = this.lostWhiteFigures;\n    newBoard.lostBlackFigures = this.lostBlackFigures;\n    newBoard.whiteKing = this.whiteKing;\n    newBoard.blackKing = this.blackKing;\n\n    return newBoard;\n  }\n\n  public highLightCells(selectedCell: Cell | null) {\n    for (let i = 0; i < this.cells.length; i++) {\n      const row = this.cells[i];\n      for (let j = 0; j < this.cells.length; j++) {\n        const target = row[j];\n        target.available = !!(\n          selectedCell?.figure?.canMove(target) &&\n          this.isAvailableMove(selectedCell.figure, selectedCell, target)\n        );\n      }\n    }\n  }\n\n  addLostFigure(figure: Figure) {\n    figure.color === Colors.BLACK\n      ? this.lostBlackFigures.push(figure)\n      : this.lostWhiteFigures.push(figure);\n  }\n\n  public addFigures() {\n    this.addQueen();\n    this.addKing();\n    this.addKnight();\n    this.addRook();\n    this.addBishop();\n    this.addPawn();\n  }\n\n  private addBishop() {\n    new Bishop(Colors.WHITE, this.getCell(2, 7), this);\n    new Bishop(Colors.WHITE, this.getCell(5, 7), this);\n    new Bishop(Colors.BLACK, this.getCell(2, 0), this);\n    new Bishop(Colors.BLACK, this.getCell(5, 0), this);\n  }\n  private addKing() {\n    this.whiteKing = new King(Colors.WHITE, this.getCell(4, 7), this);\n    this.blackKing = new King(Colors.BLACK, this.getCell(4, 0), this);\n  }\n\n  private addPawn() {\n    for (let i = 0; i < 8; i++) {\n      new Pawn(Colors.WHITE, this.getCell(i, 6), this);\n      new Pawn(Colors.BLACK, this.getCell(i, 1), this);\n    }\n  }\n\n  private addQueen() {\n    new Queen(Colors.WHITE, this.getCell(3, 7), this);\n    new Queen(Colors.BLACK, this.getCell(3, 0), this);\n  }\n\n  private addKnight() {\n    new Knight(Colors.WHITE, this.getCell(1, 7), this);\n    new Knight(Colors.WHITE, this.getCell(6, 7), this);\n    new Knight(Colors.BLACK, this.getCell(1, 0), this);\n    new Knight(Colors.BLACK, this.getCell(6, 0), this);\n  }\n\n  private addRook() {\n    new Rook(Colors.WHITE, this.getCell(0, 7), this);\n    new Rook(Colors.WHITE, this.getCell(7, 7), this);\n    new Rook(Colors.BLACK, this.getCell(0, 0), this);\n    new Rook(Colors.BLACK, this.getCell(7, 0), this);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}