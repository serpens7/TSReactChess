{"ast":null,"code":"import { FigureNames } from \"./figures/Figure\";\nimport { Queen } from \"./figures/Queen\";\nimport { Colors } from \"./Colors\";\nexport class Cell {\n  // для реакт ключей\n\n  constructor(board, x, y, color, figure) {\n    this.x = void 0;\n    this.y = void 0;\n    this.color = void 0;\n    this.figure = void 0;\n    this.board = void 0;\n    this.available = void 0;\n    //можно ли переместить фигуру\n    this.id = void 0;\n    this.x = x;\n    this.y = y;\n    this.color = color;\n    this.figure = figure;\n    this.board = board;\n    this.available = false;\n    this.id = Math.random();\n  }\n  moveFigure(target) {\n    var _this$figure;\n    if (this.figure && (_this$figure = this.figure) !== null && _this$figure !== void 0 && _this$figure.canMove(target)) {\n      this.figure.moveFigure(target);\n      if (target.figure) {\n        this.board.addLostFigure(target.figure);\n      }\n      target.setFigureForLoop(this.figure, target);\n      //  if (\n      //this.figure.canMove(this) &&\n      //   target.figure?.name === FigureNames.KING\n      //  ) {\n      //   console.log(\"шах\");\n      //  }\n      this.pawnToQueenCheck(target);\n      this.figure = null;\n    }\n  }\n  pawnToQueenCheck(target) {\n    var _this$figure2;\n    let xColor = null;\n    if (((_this$figure2 = this.figure) === null || _this$figure2 === void 0 ? void 0 : _this$figure2.name) === FigureNames.PAWN && (target.y === 0 || target.y === 7)) {\n      if (this.figure.color === Colors.BLACK) {\n        xColor = Colors.BLACK;\n      } else {\n        xColor = Colors.WHITE;\n      }\n      new Queen(xColor, target);\n    }\n  }\n  setFigureForLoop(figure, target) {\n    this.figure = figure;\n    this.figure.cell = this;\n  }\n  //кольцевая зависимость. Рефакторинг?\n\n  isEmpty() {\n    return this.figure === null;\n  }\n  isEnemy(target) {\n    if (target.figure) {\n      var _this$figure3;\n      return ((_this$figure3 = this.figure) === null || _this$figure3 === void 0 ? void 0 : _this$figure3.color) !== target.figure.color;\n    }\n    return false;\n  }\n  isRoqueAvailable(kingCell, rookCell) {\n    //if (this.isCellUnderAttack(board.getCell(kingCell.x, kingCell.y), kingCell?.figure.color))\n    const direction = kingCell.x - rookCell.x > 0 ? 1 : -1;\n  }\n  isEmptyVertical(target) {\n    if (this.x !== target.x) {\n      return false;\n    }\n    const min = Math.min(this.y, target.y);\n    const max = Math.max(this.y, target.y);\n    for (let y = min + 1; y < max; y++) {\n      if (!this.board.getCell(this.x, y).isEmpty()) {\n        return false;\n      }\n    }\n    return true;\n  }\n  isEmptyHorizontal(target) {\n    if (this.y !== target.y) {\n      return false;\n    }\n    const min = Math.min(this.x, target.x);\n    const max = Math.max(this.x, target.x);\n    for (let x = min + 1; x < max; x++) {\n      if (!this.board.getCell(x, this.y).isEmpty()) {\n        return false;\n      }\n    }\n    return true;\n  }\n  isEmptyDiagonal(target) {\n    const absX = Math.abs(target.x - this.x);\n    const absY = Math.abs(target.y - this.y);\n    if (absX !== absY) return false;\n    const dy = this.y < target.y ? 1 : -1;\n    const dx = this.x < target.x ? 1 : -1;\n    for (let i = 1; i < absY; i++) {\n      if (!this.board.getCell(this.x + dx * i, this.y + dy * i).isEmpty()) return false;\n    }\n    return true;\n  }\n  canBlackPawnMoveForward(target) {\n    const check = this.y === 1 ? target.y - 2 > this.y : target.y - 1 > this.y;\n    if (this.x !== target.x || target.y < this.y || check) {\n      return false;\n    }\n    if (!this.board.getCell(this.x, this.y + 2).isEmpty()) {\n      return false;\n    }\n    return true;\n  }\n  canWhitePawnMoveForward(target) {\n    const check = this.y === 6 ? target.y + 2 < this.y : target.y + 1 < this.y;\n    if (this.x !== target.x || target.y > this.y || check) {\n      return false;\n    }\n    if (!this.board.getCell(this.x, this.y - 2).isEmpty() && this.y === 6) {\n      return false;\n    }\n    return true;\n  }\n}","map":{"version":3,"names":["FigureNames","Queen","Colors","Cell","constructor","board","x","y","color","figure","available","id","Math","random","moveFigure","target","_this$figure","canMove","addLostFigure","setFigureForLoop","pawnToQueenCheck","_this$figure2","xColor","name","PAWN","BLACK","WHITE","cell","isEmpty","isEnemy","_this$figure3","isRoqueAvailable","kingCell","rookCell","direction","isEmptyVertical","min","max","getCell","isEmptyHorizontal","isEmptyDiagonal","absX","abs","absY","dy","dx","i","canBlackPawnMoveForward","check","canWhitePawnMoveForward"],"sources":["/workspaces/chessWithCheck/src/models/Cell.ts"],"sourcesContent":["import { Figure, FigureNames } from \"./figures/Figure\";\nimport { Queen } from \"./figures/Queen\";\nimport { Pawn } from \"./figures/Pawn\";\nimport { Board } from \"./Board\";\nimport { Colors } from \"./Colors\";\nimport { Player } from \"./Player\";\n\nexport class Cell {\n  readonly x: number;\n  readonly y: number;\n  readonly color: Colors;\n  figure: Figure | null;\n  board: Board;\n  available: boolean; //можно ли переместить фигуру\n  id: number; // для реакт ключей\n\n  constructor(\n    board: Board,\n    x: number,\n    y: number,\n    color: Colors,\n    figure: Figure | null\n  ) {\n    this.x = x;\n    this.y = y;\n    this.color = color;\n    this.figure = figure;\n    this.board = board;\n    this.available = false;\n    this.id = Math.random();\n  }\n\n\n\n\n  moveFigure(target: Cell) {\n    if (this.figure && this.figure?.canMove(target)) {\n      this.figure.moveFigure(target);\n      if (target.figure) {\n        this.board.addLostFigure(target.figure);\n      }\n      target.setFigureForLoop(this.figure, target);\n      //  if (\n      //this.figure.canMove(this) &&\n      //   target.figure?.name === FigureNames.KING\n      //  ) {\n      //   console.log(\"шах\");\n      //  }\n      this.pawnToQueenCheck(target);\n      this.figure = null;\n    }\n  }\n  pawnToQueenCheck(target: Cell): void {\n    let xColor = null;\n    if (\n      this.figure?.name === FigureNames.PAWN &&\n      (target.y === 0 || target.y === 7)\n    ) {\n      if (this.figure.color === Colors.BLACK) {\n        xColor = Colors.BLACK;\n      } else {\n        xColor = Colors.WHITE;\n      }\n      new Queen(xColor, target);\n    }\n  }\n\n  setFigureForLoop(figure: Figure, target: Cell) {\n    this.figure = figure;\n    this.figure.cell = this;\n  }\n  //кольцевая зависимость. Рефакторинг?\n\n  isEmpty(): boolean {\n    return this.figure === null;\n  }\n\n  isEnemy(target: Cell): boolean {\n    if (target.figure) {\n      return this.figure?.color !== target.figure.color;\n    }\n    return false;\n  }\n\n  isRoqueAvailable(kingCell: Cell, rookCell: Cell) {\n    //if (this.isCellUnderAttack(board.getCell(kingCell.x, kingCell.y), kingCell?.figure.color))\n  const direction = kingCell.x - rookCell.x > 0 ? 1 : -1\n  }\n\n\n  isEmptyVertical(target: Cell) {\n    if (this.x !== target.x) {\n      return false;\n    }\n\n    const min = Math.min(this.y, target.y);\n    const max = Math.max(this.y, target.y);\n\n    for (let y = min + 1; y < max; y++) {\n      if (!this.board.getCell(this.x, y).isEmpty()) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  isEmptyHorizontal(target: Cell) {\n    if (this.y !== target.y) {\n      return false;\n    }\n\n    const min = Math.min(this.x, target.x);\n    const max = Math.max(this.x, target.x);\n\n    for (let x = min + 1; x < max; x++) {\n      if (!this.board.getCell(x, this.y).isEmpty()) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  isEmptyDiagonal(target: Cell) {\n    const absX = Math.abs(target.x - this.x);\n    const absY = Math.abs(target.y - this.y);\n    if (absX !== absY) return false;\n\n    const dy = this.y < target.y ? 1 : -1;\n    const dx = this.x < target.x ? 1 : -1;\n\n    for (let i = 1; i < absY; i++) {\n      if (!this.board.getCell(this.x + dx * i, this.y + dy * i).isEmpty())\n        return false;\n    }\n    return true;\n  }\n\n  canBlackPawnMoveForward(target: Cell) {\n    const check = this.y === 1 ? target.y - 2 > this.y : target.y - 1 > this.y;\n\n    if (this.x !== target.x || target.y < this.y || check) {\n      return false;\n    }\n    if (!this.board.getCell(this.x, this.y + 2).isEmpty()) {\n      return false;\n    }\n    return true;\n  }\n  canWhitePawnMoveForward(target: Cell) {\n    const check = this.y === 6 ? target.y + 2 < this.y : target.y + 1 < this.y;\n\n    if (this.x !== target.x || target.y > this.y || check) {\n      return false;\n    }\n    if (!this.board.getCell(this.x, this.y - 2).isEmpty() && this.y === 6) {\n      return false;\n    }\n    return true;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}